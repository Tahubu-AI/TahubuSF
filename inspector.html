<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TahubuSF: Sitefinity MCP Tool Inspector</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        h1 {
            color: #F40000;
            margin-bottom: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .tool-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .tool-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            width: 300px;
            transition: transform 0.2s;
        }
        .tool-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 10px rgba(0,0,0,0.1);
        }
        .tool-title {
            font-size: 18px;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 15px;
            color: #F97D22;
        }
        .tool-description {
            color: #666;
            margin-bottom: 20px;
            font-size: 14px;
        }
        button {
            background-color: #F40000;
            background-image: linear-gradient(120deg, #F40000 20%, #A30468 60%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #A30468;
            background-image: linear-gradient(120deg, #A30468 20%, #F40000 60%);
        }
        .results {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-top: 30px;
            width: 100%;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,0.3);
            border-radius: 50%;
            border-top-color: #F40000;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .hidden {
            display: none;
        }
        .json-editor {
            width: 100%;
            min-height: 200px;
            font-family: 'Courier New', Courier, monospace;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 800px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: #F40000;
        }
        .alert {
            background-color: #f8f9fa;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 20px;
        }
        .alert.info {
            border: 1px solid #ddd;
        }
        .alert.info strong {
            font-weight: 600;
        }
        .alert.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .alert.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background-color: #d4edda;
            color: #155724;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.3s, transform 0.3s;
            max-width: 300px;
            display: flex;
            align-items: center;
        }
        .notification .icon {
            margin-right: 10px;
            font-weight: bold;
            font-size: 18px;
            min-width: 20px;
            text-align: center;
        }
        .notification.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        /* Results formatting styles */
        .formatted-results {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        .result-item {
            background-color: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 3px solid #F97D22;
        }
        .result-item h3 {
            margin-top: 0;
            color: #F40000;
            font-size: 18px;
            margin-bottom: 10px;
        }
        .result-property {
            margin-bottom: 5px;
        }
        .property-name {
            font-weight: 600;
            color: #333;
            display: inline-block;
            width: 120px;
        }
        .property-value {
            color: #555;
        }
        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .result-table th {
            background-color: #f0f0f0;
            text-align: left;
            padding: 10px;
            border-bottom: 2px solid #ddd;
            color: #444;
        }
        .result-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
        }
        .result-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <img src="/media/tahubusf-light.svg" alt="TahubuSF Logo" style="width: 350px;">
    
    <h1>Sitefinity MCP Tool Inspector</h1>
    
    <h2>News</h2>

    <div class="tool-container">
        <div class="tool-card">
            <h2 class="tool-title">News Items</h2>
            <p class="tool-description">Fetch news items from Sitefinity</p>
            <button onclick="runTool('getNews')">Run Tool</button>
            <span id="news-loading" class="loading hidden"></span>
        </div>
    </div>

    <h2>Pages</h2>

    <div class="tool-container">
        <div class="tool-card">
            <h2 class="tool-title">Pages</h2>
            <p class="tool-description">Fetch pages from Sitefinity</p>
            <button onclick="runTool('getPages')">Run Tool</button>
            <span id="pages-loading" class="loading hidden"></span>
        </div>    

        <div class="tool-card">
            <h2 class="tool-title">Page Templates</h2>
            <p class="tool-description">Fetch page templates from Sitefinity</p>
            <button onclick="runTool('getPageTemplates')">Run Tool</button>
            <span id="pagetemplates-loading" class="loading hidden"></span>
        </div>
    </div>

    <h2>Sites</h2>

    <div class="tool-container">
        <div class="tool-card">
            <h2 class="tool-title">Sites</h2>
            <p class="tool-description">Fetch sites from Sitefinity</p>
            <button onclick="runTool('getSites')">Run Tool</button>
            <span id="sites-loading" class="loading hidden"></span>
        </div>
    </div>

    <h2>Blogs</h2>

    <div class="tool-container">
        <div class="tool-card">
            <h2 class="tool-title">Blog Posts</h2>
            <p class="tool-description">Fetch blog posts from Sitefinity</p>
            <button onclick="runTool('getBlogPosts')">Run Tool</button>
            <span id="blogposts-loading" class="loading hidden"></span>
        </div>
        
        <div class="tool-card">
            <h2 class="tool-title">Parent Blogs</h2>
            <p class="tool-description">Fetch available parent blogs from Sitefinity</p>
            <button onclick="runTool('getParentBlogs')">Run Tool</button>
            <span id="parentblogs-loading" class="loading hidden"></span>
        </div>
        
        <div class="tool-card">
            <h2 class="tool-title">Create Blog Post</h2>
            <p class="tool-description">Create a new blog post draft in Sitefinity</p>
            <button onclick="openBlogEditor()">Open Editor</button>
        </div>
    </div>
    
    <div class="results">
        <h2>Results</h2>
        <div id="results-container">
            <pre id="results">Run a tool to see results...</pre>
        </div>
    </div>
    
    <!-- Blog Post Editor Modal -->
    <div id="blogEditorModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeBlogEditor()">&times;</span>
            <h2>Create Blog Post Draft</h2>
            <div class="alert info">
                <strong>Important:</strong> Parent Blog ID is required. The editor automatically selects the first available parent blog.
            </div>
            <textarea id="blogPostJson" class="json-editor">{
  "title": "New Blog Post Title",
  "content": "<h2>Blog Post Heading</h2><p>This is the main content of your blog post.</p><p>You can use HTML formatting.</p>",
  "summary": "A brief summary of this blog post",
  "parent_id": "",
  "allow_comments": true
}</textarea>
            <button onclick="createBlogPost()">Create Blog Post</button>
            <span id="createblogpost-loading" class="loading hidden"></span>
        </div>
    </div>
    
    <div id="notification" class="notification">
        <span class="icon">&#10004;</span>
        <span class="message">Blog post created successfully!</span>
    </div>
    
    <script>
        async function runTool(toolName) {
            // Show loading indicator
            const loaderId = toolName.toLowerCase().replace('get', '').replace('create', '') + "-loading";
            const loaderElement = document.getElementById(loaderId);
            if (loaderElement) {
                loaderElement.classList.remove('hidden');
            }
            
            // Set results to loading if this is a direct user action (not a background fetch)
            if (loaderElement) {
                // Reset the results container to its initial state with the pre element
                document.getElementById('results-container').innerHTML = '<pre id="results">Loading...</pre>';
            }
            
            try {
                // Call the MCP tool
                const response = await fetch('/api/run-tool', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: toolName,
                        params: {}
                    }),
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Display the results if this is a direct user action
                if (loaderElement) {
                    if (toolName === 'getParentBlogs' && data.result) {
                        // Format parent blogs results in a more readable way
                        displayParentBlogs(data.result);
                    } else if (toolName === 'getPageTemplates' && data.result) {
                        // Format page templates in a more readable way
                        formatPageTemplatesResults(data.result);
                    } else if (toolName === 'getNews' && data.result) {
                        // Format news items in a more readable way
                        formatNewsResults(data.result);
                    } else if (toolName === 'getBlogPosts' && data.result) {
                        // Format blog posts in a more readable way
                        formatBlogPostsResults(data.result);
                    } else if (toolName === 'getSites' && data.result) {
                        // Format sites in a more readable way
                        formatSitesResults(data.result);
                    } else if (toolName === 'getPages' && data.result) {
                        // Format pages in a more readable way
                        formatPagesResults(data.result);
                    } else {
                        // Display regular JSON results - ensure pre element exists
                        document.getElementById('results-container').innerHTML = '<pre id="results"></pre>';
                        document.getElementById('results').textContent = JSON.stringify(data.result, null, 2);
                    }
                }
                
                return data.result;
            } catch (error) {
                console.error('Error running tool:', error);
                if (loaderElement) {
                    // Ensure the pre element exists
                    document.getElementById('results-container').innerHTML = '<pre id="results"></pre>';
                    document.getElementById('results').textContent = `Error: ${error.message}`;
                }
                return null;
            } finally {
                // Hide loading indicator
                if (loaderElement) {
                    loaderElement.classList.add('hidden');
                }
            }
        }
        
        function openBlogEditor() {
            document.getElementById('blogEditorModal').style.display = 'block';
            
            // Automatically fetch parent blogs when opening the editor
            fetchAndPopulateParentId();
        }
        
        function closeBlogEditor() {
            document.getElementById('blogEditorModal').style.display = 'none';
        }
        
        // Function to fetch parent blogs and populate the parent_id field
        async function fetchAndPopulateParentId() {
            try {
                // Show loading in the editor
                const jsonEditor = document.getElementById('blogPostJson');
                const currentData = getCurrentEditorData();
                
                // Show temporary loading message in the JSON editor
                jsonEditor.value = "/* Fetching parent blogs... */\n" + JSON.stringify(currentData, null, 2);
                
                // Fetch parent blogs
                const parentBlogs = await runTool('getParentBlogs');
                
                if (parentBlogs && Object.keys(parentBlogs).length > 0) {
                    // Get the first parent blog ID
                    const firstParentId = Object.keys(parentBlogs)[0];
                    const firstName = parentBlogs[firstParentId];
                    
                    // Update the parent_id in the current data
                    currentData.parent_id = firstParentId;
                    
                    // Create comment with all available parent blogs
                    let blogComment = "/* Available parent blogs:\n";
                    for (const [id, title] of Object.entries(parentBlogs)) {
                        const isSelected = (id === firstParentId) ? " (SELECTED)" : "";
                        blogComment += `${title}${isSelected}: ${id}\n`;
                    }
                    blogComment += "*/\n";
                    
                    // Update the JSON editor with the comment and updated data
                    jsonEditor.value = blogComment + JSON.stringify(currentData, null, 2);
                } else {
                    // No parent blogs found, show warning
                    jsonEditor.value = "/* WARNING: No parent blogs found. You need a parent blog to create a post. */\n" + 
                                      JSON.stringify(currentData, null, 2);
                }
            } catch (error) {
                console.error("Error fetching parent blogs:", error);
            }
        }
        
        // Helper function to get current data from editor
        function getCurrentEditorData() {
            try {
                const jsonEditor = document.getElementById('blogPostJson');
                // Remove any comments before parsing
                const jsonWithoutComments = jsonEditor.value.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, '');
                return JSON.parse(jsonWithoutComments);
            } catch (e) {
                // Return default template if parsing fails
                return {
                    title: "New Blog Post Title",
                    content: "<h2>Blog Post Heading</h2><p>This is the main content of your blog post.</p><p>You can use HTML formatting.</p>",
                    summary: "A brief summary of this blog post",
                    parent_id: "",
                    allow_comments: true
                };
            }
        }
        
        async function createBlogPost() {
            // Show loading indicator
            document.getElementById('createblogpost-loading').classList.remove('hidden');
            
            try {
                // Get the JSON data from the editor
                const jsonEditor = document.getElementById('blogPostJson');
                let blogPostData;
                
                try {
                    // Remove any comments from the JSON before parsing
                    const jsonWithoutComments = jsonEditor.value.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, '');
                    blogPostData = JSON.parse(jsonWithoutComments);
                } catch (e) {
                    throw new Error(`Invalid JSON: ${e.message}`);
                }
                
                // Validate required fields
                if (!blogPostData.parent_id || blogPostData.parent_id === "REQUIRED - Use the Parent Blogs tool to get a valid ID") {
                    throw new Error("Parent blog ID (parent_id) is required. Please use the Parent Blogs tool to get a valid ID.");
                }
                
                // Call the MCP tool
                const response = await fetch('/api/run-tool', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: 'createBlogPostDraft',
                        params: blogPostData
                    }),
                });
                
                const data = await response.json();
                
                // Check if there was an error
                if (!response.ok || data.detail) {
                    // Handle error response
                    const errorMsg = data.detail || `HTTP error: ${response.status}`;
                    formatBlogPostError(errorMsg);
                    showNotification("Blog post creation failed!", "error");
                } else {
                    // Format and display the created blog post details
                    formatCreatedBlogPost(data.result);
                    
                    // Show success notification
                    showNotification("Blog post created successfully!");
                    
                    // Close the modal
                    closeBlogEditor();
                }
            } catch (error) {
                console.error('Error creating blog post:', error);
                
                // Format and display the error
                formatBlogPostError(error.message);
                
                // Show error notification
                showNotification("Blog post creation failed!", "error");
            } finally {
                // Hide loading indicator
                document.getElementById('createblogpost-loading').classList.add('hidden');
            }
        }
        
        function showNotification(message, type = "success") {
            const notification = document.getElementById('notification');
            const messageElement = notification.querySelector('.message');
            const iconElement = notification.querySelector('.icon');
            
            // Set the message text
            messageElement.textContent = message;
            
            // Update the icon based on type using decimal HTML entities
            // &#10004; = checkmark, &#10060; = X mark
            iconElement.innerHTML = type === "success" ? "&#10004;" : "&#10060;";
            
            // Reset classes
            notification.className = "notification";
            if (type === "error") {
                notification.classList.add("error");
            }
            
            notification.classList.add('show');
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                notification.classList.remove('show');
            }, 5000);
        }
        
        function formatCreatedBlogPost(blogPost) {
            const resultsContainer = document.getElementById('results-container');
            
            try {
                // Create formatted HTML output
                let html = '<div class="formatted-results">';
                html += '<div class="alert success"><strong>Success!</strong> Blog post draft created successfully.</div>';
                
                html += '<div class="result-item">';
                html += `<h3>${blogPost.Title || 'New Blog Post'}</h3>`;
                
                // Add post URL if available
                if (blogPost.ItemDefaultUrl) {
                    html += `<div class="result-property">
                        <span class="property-name">URL:</span>
                        <span class="property-value">${blogPost.ItemDefaultUrl}</span>
                    </div>`;
                }
                
                // Add ID
                html += `<div class="result-property">
                    <span class="property-name">ID:</span>
                    <span class="property-value">${blogPost.Id || 'Unknown'}</span>
                </div>`;
                
                // Add Status
                html += `<div class="result-property">
                    <span class="property-name">Status:</span>
                    <span class="property-value">Draft</span>
                </div>`;
                
                // Add Publication Date
                if (blogPost.PublicationDate) {
                    const date = new Date(blogPost.PublicationDate).toLocaleString();
                    html += `<div class="result-property">
                        <span class="property-name">Created:</span>
                        <span class="property-value">${date}</span>
                    </div>`;
                }
                
                // Add Summary if available
                if (blogPost.Summary) {
                    html += `<div class="result-property">
                        <span class="property-name">Summary:</span>
                        <span class="property-value">${blogPost.Summary}</span>
                    </div>`;
                }
                
                // Preview of content (truncated)
                if (blogPost.Content) {
                    // Strip HTML tags for preview
                    const contentText = blogPost.Content.replace(/<[^>]*>/g, ' ').substring(0, 100);
                    html += `<div class="result-property">
                        <span class="property-name">Content:</span>
                        <span class="property-value">${contentText}${blogPost.Content.length > 100 ? '...' : ''}</span>
                    </div>`;
                }
                
                html += '</div>';
                
                // Add note about Sitefinity
                html += `<div class="result-item">
                    <div class="result-property">
                        <p>The blog post has been created as a draft. You can now edit, review, and publish it in the Sitefinity admin panel.</p>
                    </div>
                </div>`;
                
                html += '</div>';
                
                // Update the results container
                resultsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error formatting created blog post:', error);
                // Fallback to showing the raw data
                resultsContainer.innerHTML = '<pre id="results"></pre>';
                document.getElementById('results').textContent = JSON.stringify(blogPost, null, 2);
            }
        }
        
        function displayParentBlogs(parentBlogs) {
            const resultsContainer = document.getElementById('results-container');
            
            try {
                if (!parentBlogs || Object.keys(parentBlogs).length === 0) {
                    resultsContainer.innerHTML = '<pre id="results">No parent blogs found.</pre>';
                    return;
                }
                
                let formattedOutput = '<div class="formatted-results">';
                formattedOutput += '<h3>Available Parent Blogs</h3>';
                
                for (const [id, title] of Object.entries(parentBlogs)) {
                    formattedOutput += `<div class="result-item">
                        <h3>${title}</h3>
                        <div class="result-property">
                            <span class="property-name">ID:</span>
                            <span class="property-value">${id}</span>
                        </div>
                    </div>`;
                }
                
                // Add a note about usage
                formattedOutput += '<div class="result-item">'+
                    '<div class="result-property">'+
                    '<p>Use one of these IDs in the \'parent_id\' field when creating a blog post.</p>'+
                    '</div></div>';
                
                formattedOutput += '</div>';
                
                // Update the results container
                resultsContainer.innerHTML = formattedOutput;
            } catch (error) {
                console.error('Error displaying parent blogs:', error);
                // Fallback to showing the raw data
                resultsContainer.innerHTML = '<pre id="results"></pre>';
                document.getElementById('results').textContent = JSON.stringify(parentBlogs, null, 2);
            }
        }
        
        // Close the modal if the user clicks outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('blogEditorModal');
            if (event.target === modal) {
                closeBlogEditor();
            }
        }
        
        function formatPageTemplatesResults(data) {
            const resultsContainer = document.getElementById('results-container');
            
            try {
                // Parse the data if it's a string (sometimes it might be pre-parsed)
                let templates = data;
                if (typeof data === 'string') {
                    // Try to identify and parse structured data in the string
                    templates = parseStructuredString(data);
                }
                
                // Create formatted HTML output
                let html = '<div class="formatted-results">';
                
                if (Array.isArray(templates)) {
                    // It's an array of template objects
                    html += '<h3>Page Templates</h3>';
                    html += '<div class="result-table-container">';
                    html += '<table class="result-table">';
                    html += '<thead><tr><th>Title</th><th>Framework</th><th>Renderer</th></tr></thead>';
                    html += '<tbody>';
                    
                    templates.forEach(template => {
                        html += `<tr>
                            <td>${template.Title || ''}</td>
                            <td>${template.Framework || ''}</td>
                            <td>${template.Renderer || 'None'}</td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table></div>';
                } else {
                    // It's a string-based format or unknown format
                    const items = data.split('\n\n').filter(item => item.trim());
                    
                    items.forEach(item => {
                        html += '<div class="result-item">';
                        
                        const lines = item.split('\n');
                        let title = 'Unknown Template';
                        
                        // Extract properties
                        lines.forEach(line => {
                            if (line.startsWith('Title:')) {
                                title = line.replace('Title:', '').trim();
                                html += `<h3>${title}</h3>`;
                            } else if (line.includes(':')) {
                                const [name, value] = line.split(':').map(s => s.trim());
                                html += `<div class="result-property">
                                    <span class="property-name">${name}:</span>
                                    <span class="property-value">${value}</span>
                                </div>`;
                            } else if (line.trim()) {
                                html += `<div class="result-property">${line}</div>`;
                            }
                        });
                        
                        html += '</div>';
                    });
                }
                
                html += '</div>';
                
                // Update the results container
                resultsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error formatting page templates:', error);
                // Fallback to showing the raw data
                resultsContainer.innerHTML = '<pre id="results"></pre>';
                document.getElementById('results').textContent = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            }
        }
        
        function formatNewsResults(data) {
            const resultsContainer = document.getElementById('results-container');
            
            try {
                // Parse the data if needed
                let newsItems = data;
                if (typeof data === 'string' && data.includes('\n\n')) {
                    // Try to parse structured string data
                    newsItems = parseStructuredString(data);
                }
                
                // Create formatted HTML output
                let html = '<div class="formatted-results">';
                html += '<h3>News Items</h3>';
                
                if (Array.isArray(newsItems)) {
                    // It's an array of news item objects
                    newsItems.forEach(item => {
                        html += `<div class="result-item">
                            <h3>${item.Title || 'Untitled News Item'}</h3>`;
                            
                        // Add common news properties
                        if (item.PublicationDate) {
                            const date = new Date(item.PublicationDate).toLocaleDateString();
                            html += `<div class="result-property">
                                <span class="property-name">Published:</span>
                                <span class="property-value">${date}</span>
                            </div>`;
                        }
                        
                        if (item.Summary) {
                            html += `<div class="result-property">
                                <span class="property-name">Summary:</span>
                                <span class="property-value">${item.Summary}</span>
                            </div>`;
                        }
                        
                        html += '</div>';
                    });
                } else {
                    // It's a string-based format or unknown format
                    const items = data.split('\n\n').filter(item => item.trim());
                    
                    items.forEach(item => {
                        html += '<div class="result-item">';
                        
                        const lines = item.split('\n');
                        let title = 'Unknown News Item';
                        
                        // Extract properties
                        lines.forEach((line, index) => {
                            if (index === 0) {
                                // Assume first line is title
                                title = line.trim();
                                html += `<h3>${title}</h3>`;
                            } else if (line.includes(':')) {
                                const [name, value] = line.split(':').map(s => s.trim());
                                html += `<div class="result-property">
                                    <span class="property-name">${name}:</span>
                                    <span class="property-value">${value}</span>
                                </div>`;
                            } else if (line.trim()) {
                                html += `<div class="result-property">${line}</div>`;
                            }
                        });
                        
                        html += '</div>';
                    });
                }
                
                html += '</div>';
                
                // Update the results container
                resultsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error formatting news items:', error);
                // Fallback to showing the raw data
                resultsContainer.innerHTML = '<pre id="results"></pre>';
                document.getElementById('results').textContent = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            }
        }
        
        function formatBlogPostsResults(data) {
            const resultsContainer = document.getElementById('results-container');
            
            try {
                // Create formatted HTML output
                let html = '<div class="formatted-results">';
                html += '<h3>Blog Posts</h3>';
                
                if (typeof data === 'object' && data !== null) {
                    // It might be a parsed object with blog posts
                    const posts = data.value || data;
                    
                    if (Array.isArray(posts)) {
                        posts.forEach(post => {
                            html += `<div class="result-item">
                                <h3>${post.Title || 'Untitled Post'}</h3>`;
                                
                            // Add common blog post properties
                            if (post.PublicationDate) {
                                const date = new Date(post.PublicationDate).toLocaleDateString();
                                html += `<div class="result-property">
                                    <span class="property-name">Published:</span>
                                    <span class="property-value">${date}</span>
                                </div>`;
                            }
                            
                            if (post.Summary) {
                                html += `<div class="result-property">
                                    <span class="property-name">Summary:</span>
                                    <span class="property-value">${post.Summary}</span>
                                </div>`;
                            }
                            
                            if (post.Id) {
                                html += `<div class="result-property">
                                    <span class="property-name">ID:</span>
                                    <span class="property-value">${post.Id}</span>
                                </div>`;
                            }
                            
                            html += '</div>';
                        });
                    } else {
                        // Single post or unknown format
                        html += formatGenericResult(data);
                    }
                } else if (typeof data === 'string') {
                    // Try to parse the string data
                    const items = data.split('\n\n').filter(item => item.trim());
                    
                    if (items.length > 0) {
                        items.forEach(item => {
                            html += '<div class="result-item">';
                            
                            const lines = item.split('\n');
                            let title = 'Unknown Post';
                            
                            // Extract properties
                            lines.forEach((line, index) => {
                                if (index === 0) {
                                    // Assume first line is title
                                    title = line.trim();
                                    html += `<h3>${title}</h3>`;
                                } else if (line.includes(':')) {
                                    const [name, value] = line.split(':').map(s => s.trim());
                                    html += `<div class="result-property">
                                        <span class="property-name">${name}:</span>
                                        <span class="property-value">${value}</span>
                                    </div>`;
                                } else if (line.trim()) {
                                    html += `<div class="result-property">${line}</div>`;
                                }
                            });
                            
                            html += '</div>';
                        });
                    } else {
                        html += `<div class="result-item">
                            <h3>Blog Posts</h3>
                            <div class="result-property">${data}</div>
                        </div>`;
                    }
                }
                
                html += '</div>';
                
                // Update the results container
                resultsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error formatting blog posts:', error);
                // Fallback to showing the raw data
                resultsContainer.innerHTML = '<pre id="results"></pre>';
                document.getElementById('results').textContent = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            }
        }
        
        function formatSitesResults(data) {
            const resultsContainer = document.getElementById('results-container');
            
            try {
                // Create formatted HTML output
                let html = '<div class="formatted-results">';
                html += '<h3>Sites</h3>';
                
                if (typeof data === 'object' && data !== null) {
                    const sites = data.value || data;
                    
                    if (Array.isArray(sites)) {
                        sites.forEach(site => {
                            html += `<div class="result-item">
                                <h3>${site.Title || site.Name || 'Unnamed Site'}</h3>`;
                                
                            // Add all site properties except Title/Name
                            for (const [key, value] of Object.entries(site)) {
                                if (key !== 'Title' && key !== 'Name') {
                                    html += `<div class="result-property">
                                        <span class="property-name">${key}:</span>
                                        <span class="property-value">${value}</span>
                                    </div>`;
                                }
                            }
                            
                            html += '</div>';
                        });
                    } else {
                        // Single site or unknown format
                        html += formatGenericResult(data);
                    }
                } else if (typeof data === 'string') {
                    // Process string data with newline-separated sites
                    const sites = data.split('\n\n').filter(item => item.trim());
                    
                    sites.forEach(siteString => {
                        html += '<div class="result-item">';
                        
                        // Parse the site properties
                        const properties = {};
                        const lines = siteString.split('\n').map(line => line.trim()).filter(line => line);
                        
                        let title = 'Unnamed Site';
                        lines.forEach(line => {
                            // Try to extract property name and value
                            if (line.includes(':')) {
                                const colonIndex = line.indexOf(':');
                                const name = line.substring(0, colonIndex).trim();
                                const value = line.substring(colonIndex + 1).trim();
                                
                                properties[name] = value;
                                
                                // If this is the title/name, save it
                                if (name === 'Title' || name === 'Name') {
                                    title = value;
                                }
                            }
                        });
                        
                        // Add the title
                        html += `<h3>${title}</h3>`;
                        
                        // Add all other properties except Title/Name
                        for (const [key, value] of Object.entries(properties)) {
                            if (key !== 'Title' && key !== 'Name') {
                                html += `<div class="result-property">
                                    <span class="property-name">${key}:</span>
                                    <span class="property-value">${value}</span>
                                </div>`;
                            }
                        }
                        
                        html += '</div>';
                    });
                }
                
                html += '</div>';
                
                // Update the results container
                resultsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error formatting sites:', error);
                // Fallback to showing the raw data
                resultsContainer.innerHTML = '<pre id="results"></pre>';
                document.getElementById('results').textContent = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            }
        }
        
        function formatPagesResults(data) {
            const resultsContainer = document.getElementById('results-container');
            
            try {
                // Create formatted HTML output
                let html = '<div class="formatted-results">';
                html += '<h3>Pages</h3>';
                
                if (typeof data === 'object' && data !== null) {
                    const pages = data.value || data;
                    
                    if (Array.isArray(pages)) {
                        pages.forEach(page => {
                            html += `<div class="result-item">
                                <h3>${page.Title || 'Untitled Page'}</h3>`;
                                
                            // Add common page properties
                            for (const [key, value] of Object.entries(page)) {
                                if (key !== 'Title') {
                                    html += `<div class="result-property">
                                        <span class="property-name">${key}:</span>
                                        <span class="property-value">${value}</span>
                                    </div>`;
                                }
                            }
                            
                            html += '</div>';
                        });
                    } else {
                        // Single page or unknown format
                        html += formatGenericResult(data);
                    }
                } else if (typeof data === 'string') {
                    // Process string data with newline-separated pages
                    const pages = data.split('\n\n').filter(item => item.trim());
                    
                    pages.forEach(pageString => {
                        html += '<div class="result-item">';
                        
                        // Parse the page properties
                        const properties = {};
                        const lines = pageString.split('\n').map(line => line.trim()).filter(line => line);
                        
                        lines.forEach(line => {
                            // Try to extract property name and value
                            if (line.includes(':')) {
                                const colonIndex = line.indexOf(':');
                                const name = line.substring(0, colonIndex).trim();
                                const value = line.substring(colonIndex + 1).trim();
                                
                                properties[name] = value;
                                
                                // If this is the title, add it as a header
                                if (name === 'Title') {
                                    html += `<h3>${value}</h3>`;
                                }
                            }
                        });
                        
                        // Add all other properties except Title
                        for (const [key, value] of Object.entries(properties)) {
                            if (key !== 'Title') {
                                html += `<div class="result-property">
                                    <span class="property-name">${key}:</span>
                                    <span class="property-value">${value}</span>
                                </div>`;
                            }
                        }
                        
                        html += '</div>';
                    });
                }
                
                html += '</div>';
                
                // Update the results container
                resultsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error formatting pages:', error);
                // Fallback to showing the raw data
                resultsContainer.innerHTML = '<pre id="results"></pre>';
                document.getElementById('results').textContent = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            }
        }
        
        function parseStructuredString(str) {
            // Try to identify and parse a string with structured data
            try {
                // First check if it's JSON
                return JSON.parse(str);
            } catch (e) {
                // Not JSON, might be another structured format
                const items = [];
                
                // Split by double newlines which typically separate items
                const chunks = str.split('\n\n').filter(chunk => chunk.trim());
                
                chunks.forEach(chunk => {
                    const item = {};
                    const lines = chunk.split('\n');
                    
                    lines.forEach(line => {
                        if (line.includes(':')) {
                            const [key, value] = line.split(':').map(s => s.trim());
                            item[key] = value;
                        }
                    });
                    
                    if (Object.keys(item).length > 0) {
                        items.push(item);
                    }
                });
                
                return items.length > 0 ? items : str;
            }
        }
        
        function formatGenericResult(data) {
            if (typeof data === 'object' && data !== null) {
                let html = '';
                
                // For objects, create a property list
                for (const [key, value] of Object.entries(data)) {
                    if (typeof value === 'object' && value !== null) {
                        html += `<div class="result-property">
                            <span class="property-name">${key}:</span>
                            <span class="property-value">${JSON.stringify(value)}</span>
                        </div>`;
                    } else {
                        html += `<div class="result-property">
                            <span class="property-name">${key}:</span>
                            <span class="property-value">${value}</span>
                        </div>`;
                    }
                }
                
                return html;
            } else if (typeof data === 'string') {
                return `<div class="result-property">${data}</div>`;
            } else {
                return `<div class="result-property">${JSON.stringify(data)}</div>`;
            }
        }
        
        function formatBlogPostError(errorMessage) {
            const resultsContainer = document.getElementById('results-container');
            
            try {
                // Create formatted HTML output
                let html = '<div class="formatted-results">';
                html += `<div class="alert error"><strong>Error!</strong> Blog post creation failed.</div>`;
                
                html += '<div class="result-item">';
                html += `<h3>Blog Post Creation Error</h3>`;
                
                // Extract details from the error message
                let errorDetails = errorMessage;
                
                // Try to parse and format the error message if it's more complex
                if (errorMessage.includes("Failed to create blog post draft:")) {
                    // The error might contain multiple lines or details
                    const lines = errorMessage.split('\n');
                    errorDetails = '';
                    
                    lines.forEach(line => {
                        // Format each line as a separate detail
                        errorDetails += `<div class="result-property">
                            <span class="property-value">${line}</span>
                        </div>`;
                    });
                } else {
                    // Simple error message
                    errorDetails = `<div class="result-property">
                        <span class="property-value">${errorMessage}</span>
                    </div>`;
                }
                
                html += errorDetails;
                html += '</div>';
                
                // Add possible solutions
                html += `<div class="result-item">
                    <h3>Possible Solutions</h3>
                    <div class="result-property">
                        <p>1. Make sure you've provided a valid parent blog ID</p>
                        <p>2. Check that your blog post title and content are valid</p>
                        <p>3. Verify that Sitefinity is accessible and working correctly</p>
                    </div>
                </div>`;
                
                html += '</div>';
                
                // Update the results container
                resultsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error formatting blog post error:', error);
                // Fallback to showing the raw error
                resultsContainer.innerHTML = '<pre id="results"></pre>';
                document.getElementById('results').textContent = errorMessage;
            }
        }
    </script>
</body>
</html> 